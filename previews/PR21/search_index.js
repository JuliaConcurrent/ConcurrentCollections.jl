var documenterSearchIndex = {"docs":
[{"location":"#ConcurrentCollections.jl","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.jl","text":"","category":"section"},{"location":"","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.jl","text":"","category":"page"},{"location":"#Collections","page":"ConcurrentCollections.jl","title":"Collections","text":"","category":"section"},{"location":"","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.jl","text":"ConcurrentQueue\nConcurrentStack\nWorkStealingDeque","category":"page"},{"location":"#ConcurrentCollections.ConcurrentQueue","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.ConcurrentQueue","text":"ConcurrentQueue{T}()\n\nConcurrent queue of objects of type T.\n\nUse push! to insert an element at the tail and trypopfirst! to retrieve and remove an element at the head.\n\nImplementation detail: It implements the Michael and Scott queue.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> queue = ConcurrentQueue{Int}();\n\njulia> push!(queue, 1);\n\njulia> push!(queue, 2);\n\njulia> popfirst!(queue)\n1\n\njulia> trypopfirst!(queue)\nSome(2)\n\njulia> trypopfirst!(queue)  # returns nothing\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentCollections.ConcurrentStack","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.ConcurrentStack","text":"ConcurrentStack{T}()\n\nConcurrent stack of objects of type T.\n\nUse push! to insert an element and trypop! to retrieve and remove an element.\n\nIt implements the Treiber stack.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> stack = ConcurrentStack{Int}();\n\njulia> push!(stack, 1);\n\njulia> push!(stack, 2);\n\njulia> pop!(stack)\n2\n\njulia> trypop!(stack)\nSome(1)\n\njulia> trypop!(stack)  # returns nothing\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentCollections.WorkStealingDeque","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.WorkStealingDeque","text":"WorkStealingDeque{T}()\n\nConcurrent work-stealing \"deque\" of objects of type T.\n\nThis is not a full deque in the sense that:\n\npush! and trypop! operating at the tail of the collection can only be executed by a single task.\ntrypopfirst! (aka steal) for retrieving and removing an element at the head can be invoked from any tasks. However, there is no pushfirst!.\n\nImplementation detail: It implements the dynamic circular work-stealing deque by Chase and Lev (2005).\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> deque = WorkStealingDeque{Int}();\n\njulia> push!(deque, 1);\n\njulia> push!(deque, 2);\n\njulia> push!(deque, 3);\n\njulia> trypop!(deque)\nSome(3)\n\njulia> fetch(Threads.@spawn trypopfirst!(deque))\nSome(1)\n\njulia> fetch(Threads.@spawn popfirst!(deque))\n2\n\njulia> trypopfirst!(deque)  # returns nothing\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"ConcurrentCollections.jl","title":"Functions","text":"","category":"section"},{"location":"","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.jl","text":"trypop!\ntrypopfirst!","category":"page"},{"location":"#ConcurrentCollections.trypop!","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.trypop!","text":"trypop!(collection) -> Some(value::T) or nothing\n\nTry to pop a value from the tail of collection. Return Some(value) if it is non-empty.  Return nothing if empty.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> stack = ConcurrentStack{Int}();\n\njulia> push!(stack, 1);\n\njulia> trypop!(stack)\nSome(1)\n\njulia> trypop!(stack)  # returns nothing\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentCollections.trypopfirst!","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.trypopfirst!","text":"trypopfirst!(collection) -> Some(value::T) or nothing\n\nTry to pop a value from the head of collection. Return Some(value) if it is non-empty.  Return nothing if empty.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> queue = ConcurrentQueue{Int}();\n\njulia> push!(queue, 1);\n\njulia> trypopfirst!(queue)\nSome(1)\n\njulia> trypopfirst!(queue)  # returns nothing\n\n\n\n\n\n","category":"function"},{"location":"#Experimental","page":"ConcurrentCollections.jl","title":"Experimental","text":"","category":"section"},{"location":"","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.jl","text":"ConcurrentDict\nmodify!\ntryget\nKeep\nDelete","category":"page"},{"location":"#ConcurrentCollections.ConcurrentDict","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.ConcurrentDict","text":"ConcurrentDict{K,V}()\n\nConcurrent dictionary.  All operations are lock-free except when the dictionary is resized.\n\nwarning: Warning\nConcurrentDict is experimental because it cannot be implemented with the builtin atomics.\n\nnote: Note\nAlthough tasks wait on concurrent modifications (e.g., setindex!) during resize, the worker threads participate in the resize to avoid wasting CPU resources.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> dict = ConcurrentDict{String,Int}();\n\njulia> dict[\"hello\"] = 1;\n\njulia> dict[\"hello\"]\n1\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentCollections.modify!","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.modify!","text":"modify!(f, dict::ConcurrentDict{K,V}, key::K) -> y\n\nAtomically update key slot of dict using a function f.\n\nIf key does not exist, f is called with nothing. The call f(nothing) must return either (1) nothing to keep the slot unoccupied or (2) Some(value::V) to insert value.\n\nIf key exist, f is called with a ref such that ref[] retrieves the value corresponding to the key.  The call f(ref) must return either (1) nothing to delete the slot, (2) Some(valueâ€²::V) to insert value, (3) Keep(ans) to return y = Keep(ans) from modify!, or (4) Delete(ans) to delete slot and return a value y = Delete(ans) from modify!.\n\nThe function f may be called more than once if multiple tasks try to modify the dictionary.\n\nExamples\n\njulia> using ConcurrentCollections\n\njulia> dict = ConcurrentDict{String,Int}();\n\njulia> modify!(dict, \"hello\") do _\n           Some(1)\n       end\nSome(1)\n\njulia> modify!(dict, \"hello\") do ref\n           Some(something(ref[]) + 1)\n       end\nSome(2)\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentCollections.tryget","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.tryget","text":"tryget(dict::ConcurrentDict{K,V}, key) -> Some(value::T) or nothing\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentCollections.Keep","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.Keep","text":"Keep(ans)\n\nA special type used in modify! to indicate that a slot should be remain unchanged while propagating the result ans of some computation to the caller.\n\nThat is to say,\n\ny = modify!(dict, key) do value\n    Keep(f(something(value)))\nend\ny[]\n\nis an optimization of\n\nr = Ref{Any}()\nmodify!(dict, key) do value\n    r[] = f(something(value))\n    Some(value)\nend\nr[]\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentCollections.Delete","page":"ConcurrentCollections.jl","title":"ConcurrentCollections.Delete","text":"Delete(ans)\n\nA special type used in modify! to indicate that a slot should be removed.\n\nThat is to say\n\ny = modify!(dict, key) do value\n    Delete(f(something(value)))\nend\ny[]\n\nis an optimization of\n\nr = Ref{Any}()\nmodify!(dict, key) do value\n    r[] = f(something(value))\n    nothing\nend\nr[]\n\n\n\n\n\n","category":"type"}]
}
